Transaction	
	其实指的是一组操作；里面包含很多的逻辑，只要有一个逻辑没有执行成功，那么就算失败，则所有的数据都回归到最初的状(回滚)


使用命令行方式演示事务
	1. 关闭自动提交功。这样不自动输入commit，update等就不会成功;
		show variables like '%commit%';
		set autocommit = off;
	2. 开始事务/提交、回滚
		start transaction;
		update ...
		rollback;  /   commit；
		
	如果用java实现，就注意三个地方就行：关闭自动提交、提交、回滚
		conn = JDBCUtil.getConn();
		conn.setAutoCommit(false);
		...
		conn.commit();
		conn.rollback();


事务特点 (面试)
	四个ACID
	原子性：事务中包含的逻辑不可分割。原子是物理中的最小单位，不可分割。
	一致性：事务执行前后，数据的完整性保持一致
	隔离性：事务在执行期间，不应该受到其他事务影响；
	持久性：事务执行成功，那么数据应该持久保存到磁盘上


事务的安全隐患
	隔离级别
		读未提交						read uncommitted	脏读
		读已提交(oracle默认)			read committed		不可重复读
		可重复度(mysql默认)			repeatable read		幻读
		可串行化						serializable		最严格的，资源消耗最大
	
	效率划分 	读未提交>读已提交>可重复读>可串行化   高到低
	按拦截度  	可串行化>可重复度>读已提交>读未提交
	
	select @@tx_isolation;		mysql查看当前隔离级别
	set session transaction isolation level read uncommitted;	设置为读未提交
	
	不考虑隔离级别设置，会出现以下几个问题
		读的问题		脏读，不可重复读 ，幻读
		写的问题		丢失更新
		
		
脏读	: 	一个事务读到了另一个事务还未提交的数据；
			开两个mysql的命令窗口, A窗口的隔离级别设置为读未提交(read uncommitted)
			两个窗口都开启事务，B窗口做了对表的修改，但是没提交；
			A窗口，去查询这个表，能看到B修改的内容，这就是脏读；
			读到其他人没提交数据。
			
		解决办法
			A窗口改成读已提交(read committed)，这样就不会出现脏读
			没提交读到的还是原来的数据，只有另外那个窗口修改并提交了才能看到改变的数据；
		
		但是引发了第二个问题：
			不可重复读，两次读的不一样；
			所以有第三个：可重复读(repeatable read )
			另外一个窗口改动了数据，这个窗口一直是查出原来的数据
	
幻读：	一个事务读到了另一个事务已经插入insert的数据，导致多次查询结果不一致，比较少见到
		跟不可重复读有些相似，但不可重复读针对的是update或delete，幻读针对的insert。
			如果有一个连接的隔离级别设置了串行化(serializable)，那么谁先打开事务，就有先执行的权利。
			谁后打开事务，就只能等前面那个事务提交或者回滚才能执行，无论是修改还是查询都得等，界面上卡主，等另外一个提交或是回滚才行。
			当然这些应该都是针对同一个表
			这个隔离级别表少用，会造成性能上的问题，效率比较低
	
			serializable	串行化，排队来，一串串的，前面的先执行	前面的问题都解决了，但是性能上会差些
	
	事务只是针对连接对象，如果再开一个连接对象，那么是默认的提交

	
丢失更新：
	两个人同时开启事务，查询了student表， A改了name先提交；B后改了age再提交；
	最终数据库保存的是age的修改，name还是原来的；
	
	如果B是回滚，他会发现数据怎么变化了(这里不考虑隔离级别)；
	
	解决丢失更新两种方式：
		悲观锁
			还没开始做就认为一定会出现丢失更新，所以查询的时候先加上 for update
				select * from student for update 
				for update  数据库的锁机制，排他锁
			一个人执行了这个语句，那么另外一个人操作不了这个表，会卡主，只有等你提交或者回滚了，另外一个才能执行。
			
		乐观锁
			一定不会有出现丢失更新
			要求程序员自己控制，给数据库表一个字段version
			
			A事务先提交，数据库version变成1
			B事务在提交的时候，比对数据库version和自己的version，不一样，不允许提交，要先更新；
			这种操作需要程序员自己去写代码处理，具体怎么知道version变化了都要去写程序；后面hibernate会有关系到
			
			